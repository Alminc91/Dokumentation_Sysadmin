\documentclass[12pt]{article}
 \usepackage[german]{babel}
 \usepackage[utf8]{inputenc}
 \usepackage{listings}
  \usepackage{color}
 \usepackage{graphicx}
 \author{Denis Herdt, Almin Causevic}
 \title{ROS auf dem Rapberry Pi}
 \setlength{\parindent}{0pt}                   % Einrueckung 1. Zeile eines Absatzes
 \setlength{\parskip}{5pt plus 2pt minus 1pt}  % Abstand zwischen Absaetzen
 \frenchspacing
 \sloppy
  \lstset{
   basicstyle=\small\ttfamily,
   keywordstyle=\bfseries\ttfamily\color{orange},
   stringstyle=\color{green}\ttfamily,
   commentstyle=\color{middlegray}\ttfamily,
   emph={square}, 
   emphstyle=\color{blue}\texttt,
   emph={[2]root,base},
   emphstyle={[2]\color{black}\texttt},
   showstringspaces=false,
   flexiblecolumns=false,
   tabsize=2,
   frame=tBlR
   numbers=left,
   numberstyle=\tiny,
   numberblanklines=false,
   stepnumber=1,
   numbersep=10pt,
   xleftmargin=15pt
 }
 
 
\begin{document}
%4-20 Seiten
\begin{figure}[h]

\includegraphics[width=4cm]{hs-logo.jpg}
\end{figure}
Fakultät für Elektrotechnik und Informatik

\vspace{3cm}

\begin{center}

{\bf \huge ROS auf dem Raspberry Pi}
\vspace{4cm}

14 November, 2013
\vspace{1cm}

Systemadministration Projekt in Angewandter Informatik \\
von Denis Herdt und Almin Causevic

\end{center}

\pagebreak

\tableofcontents

\pagebreak

\section{Einleitung}
%1-2 Seiten
\subsection{Motivation}

Wir haben uns für dieses Thema entschieden, weil wir mit Hard- und Software arbeiten wollten. 

Wir haben mitbekommen, wie umständlich z.B. der Roboter ''Volksbot'' im Robotiklabor der Hochschule mit einem zusätzlichen, auf dem Roboter platzierten Laptop gesteuert werden muss, der unnötig Platz und Gewicht beansprucht. Deshalb haben wir uns entschlossen, dieses Problem mithilfe des kleinen und leichten Raspberry Pi zu lösen.
Die Idee stieß auch auf großes Interesse bei den Labormitarbeitern und bringt viel praktischen Nutzen.

Unser Ziel möchten wir mithilfe des Software-Frameworks ROS (Robot Operating System) realisieren.
Für ROS haben wir uns entschieden, weil es zur Zeit die aktuellste und inovativste Methode ist, ein flexibles Netzwerk von Komponenten für z.B. die Robotersteuerung zu realisieren. Es wird weltweit eingesetzt und könnte auch in Zukunft sehr nützlich werden.

Durch die Kombination mit der Mächtigkeit und Flexibilität von ROS und der geringen Größe und dem niedrigen Energieverbrauch des Pi eröffnen sich außerdem neue und effizientere Einsatzmöglichkeiten.

Sehr gut finden wir auch die Tatsache, dass wir mit Linux arbeiten können und dieses Projekt viel Konfiguration des Betriebssystems voraussetzt, da wir auch gerne mehr Praxiserfahrung mit Linux haben möchten.

%Roboter Lab Anwendung von ROS und Möglichkeit, Roboter zu nutzen

%Interesse der Lab-Crew an Umsetzung ROS mit Raspberry Pi

%Kombination Hard-/Software

%Einarbeitung in Kommunikations Framework ROS

%Mit Hardware in Berührung zu kommen

%Konfiguration mit Linux

%Nodes nun mit Hardware (Pi) realisierbar

\subsection{Zielsetzung}


Unser Hauptziel besteht darin, ROS auf dem Raspberry Pi aufzusetzen und zu nutzen. Dieses Ziel wird wie folgt unterteilt:\\

Zunächst möchten wir ein passendes, auf Linux basierendes Betriebssystem auswählen und auf dem Raspberry Pi aufsetzen. In diesem Fall haben wir uns für Raspbian entschieden, da es zusätzlich am kopatibelsten zu ROS ist.

Als nächstes wählen wir einen geeigneten Roboter aus. Die Kriterien dafür erarbeiten wir uns aus einer vorangegangenen ROS-Recherche.

Im Anschluss setzen wir ROS auf dem Raspberry Pi und mehreren Linux-Rechnern auf und stellen ein WLAN-Netzwerk zwischen den verschiedenen ROS-Komponenten her.
Dieses Netzwerk wird mithilfe von Testausgaben überprüft.

Damit ist eine Grundlage für weitere Anwendungen für ROS auf dem Raspberry geschaffen.\\

{\bf optional}

Bleibt am Ende noch genug Zeit, kompilieren wir ein Steuerungspaket für den ''Volksbots'' auf dem Raspberry. Zur Verbesserung der Usability integrieren wir ein Smartphone ins ROS-Netzwerk. Die Bewegungsrichtung und -geschwindigkeit des Roboters soll durch das Schwenken des Smartphones bestimmt werden.

Haben wir damit Erfolg und wiederum genügend Zeit zur Verfügung, sprechen wir die integrierte Kamera des Roboters an und streamen das Bild mithilfe des Netzwerkes auf einen externen Bildschirm.

Da zukünftige Roboter Ihre Umgebung erkennen und sich sicher im Raum bewegen 
sollen, sehen wir diese Tests als nützlich an.

%Roboter durch einen Raspberry Pi mithilfe von ROS steuern
%Bild einer Webcam durch ROS auf einen Bildschirm streamen

\subsection{Eigene Leistung}

Das ''neue'' an diesem Projekt bezieht sich
%Unsere Leistung bezieht sich
auf die Ablösung eines Laptops durch den kleineren und leichteren Raspberry Pi als ROS-Komponente am ausgewählten Roboter. Desweiteren möchten wir herausfinden, ob die Leistung des Pi für diese Aufgabe ausreicht.

%anstatt Linux PC wird Pi benutzt

\subsection{Aufbau der Arbeit}

\begin{itemize}

\item Recherche über Linux Systeme auf dem Raspberry Pi
\item Passendes Linux System auf Raspberry Pi gesetzt			
\item Recherche über ROS
\item Geeigneten Roboter gewählt (Recherche Verfügbarkeit, Komponenten etc.)
\item Komponenten geschafft (Wlan Stick, Akkupack, etc.)
\item ROS auf Raspberry Pi aufgesetzt
\item Netzwerk zwischen mehreren ROS-Komponenten hergestellt
\item Netzwerk mithilfe von Testausgaben überprüft \\

\end{itemize}

{\bf optional}

\begin{itemize}

\item Robotersteuerung wird zur Zeit implementiert


%Roboter durch einen Raspberry Pi mithilfe von ROS steuern
%Bild einer Webcam durch ROS auf einen Bildschirm streamen

\end{itemize}

\section{Grundlagen}
%6-8 Seiten

\subsection{Raspberry Pi Hardwarekomponenten}

Der Raspberry Pi ist ein kreditkartengroßer Einplatinencomputer, der von der Raspberry Pi Foundation entwickelt wurde.
Wir benutzen für dieses Projekt das leistungsstärkere Modell B.
%Zitate für die techn. Details?
\parbox{8cm}{
Technische Details:
\begin{itemize}
\item Preis: ca. 35 Euro
\item Prozessor: ARM1176JZF-S (700 MHz)
\item Broadcom VideoCore IV
\item SDRAM: 512 MB
\item Bis zu 16 GPIO-Pins
\item USB-Anschlüsse: 2
\item FBAS, HDMI
\end{itemize}
}
\hfill
\parbox{5cm}{
\includegraphics[width=5cm]{Raspi.jpg}
}
\begin{itemize}
\item 3,5-mm-Klinkenstecker (analog), HDMI (digital)
\item Kartenleser für SD (SDHC und SDXC)/MMC/SDIO
\item 10/100-MBit-Ethernet-Controller 
\item 5 V, 700 mA (3,5 Watt)
\item 5-V-Micro-USB-Anschluss (Micro-B), alternativ 4 x AA-Batterien
\end{itemize}

Für Test und Kontrollausgaben benutzen wir einen am HDMI-Ausgang angeschlossenen Monitor.

Für den Anschluss an einen Bildschirm benutzen den HDMI Ausgang.
Diesen benutzen wir für Kontrollausgaben und Tests.

Als Stromquelle steht ein Akkupack ......(Firma,Modell) zum Einsatz. 
Hierbei ist wichtig, dass der Raspberry mind. 700 mA, besser 1 A zur Stromversorgung bekommt. 
Bei niedrigerer Amperzahl arbeitet der PC oft nicht zuverlässig.

Ein schneller und großer RAM Speicher ist für unsere Zwecke wichtig, da viele Signale, teils sogar synchron, verarbEin 17-Zoll Monitor wird für die Bildschirmausgabe des Raspberry über HDMI zu DVI benutzteitet werden müssen.

Für die Datenübertragung über das Netz benutzen wir einen Standard 300Mbit/s Wlan-Stick.

Der Raspberry Pi arbeitet mit einer ARM-Prozessorarchitektur.
Diese Architektur wird gerne für embedded Systems, wie PDAs oder Router, eingesetzt.

Sie ist auch auf jedem Smartphone zu finden, da sie den Vorteil einer sehr geringen Leistungsaufnahme bietet. 

%Konfiguration von Linux???
Erwähnenswert ist die Architektur deshalb, weil wir im Laufe des Projektes Schwierigkeiten hatten, auf die wir später eingehen werden
Wir benutzen das auf Linux basierende Betriebssystem Raspbian.
Dabei handelt sich um ein für Raspberry Pi optimiertes open-source Debian-System.
Es enthält viele für die ARM-Architektur vorkompilierte Pakete (über 35.000), dazu auch Features wie etwa eine GUI.

Das System braucht 3GB Speicherbedarf unserer 16GB großen SD-Karte.
Der zusätzliche Speicherplatz wäre nötig, falls man vorhat, Log-Dateien und Ähnliches direkt auf dem Raspberry Pi zu speichern. 
In unserem Fall übernehmen das jedoch die leistungsstärkeren PC's über das ROS Netzwerk.

GPIO (General Purpose Input/Output) ist ein weiteres interessantes Feature des Raspberry Pi.
Es gibt uns die Möglichkeit, jegliche Hardware-Funktionalität anzusteuern.
Beispielsweise können LED-Leuchten oder der Start-Knopf der Kaffeemaschine damit über ROS gesteuert werden.
Wir konnten uns leider jedoch zeitlich bedingt nicht mehr mit dieser Thematik beschäftigen, es bietet aber Anreiz für noch mehr Ansätze und Umsetzungen mithilfe des Raspberry Pi und ROS.


\subsection{Smartphone}

Es wird ein auf Android basierendes Smartphone verwendet.
Wir benutzen auf dem Smartphone eine in einer Projekt-Arbeit entstandene App.
Sie bindet sich an einen ROS-Master (später näher erläutert) und übergibt die X und -Y Koordinaten relativ zu sich weiter.
Diese Werte können für die Steuerung des Motors verwendet werden, indem jeweils ein Wert an eine Radachse geliefert wird. Dieser Wert bildet die Geschwindigkeit des Rades ab.
Zur erleichterten Bedienung stellt uns die App eine GUI zur Verfügung. 

\subsection{Volksbot}

VolksBot ist ein Roboterbaukastensystem.
Mit Hilfe des Baukastens können sehr schnell und preiswert unterschiedlichste Varianten mobiler Roboter hergestellt werden.
Der Volksbot wurde an der Hochschule Weingarten für den RoboCup verwendet.
%Wir brauchen hier mehr Infos, wo wurde er verwendet, Besonderheiten
%Bild
\subsection{ROS}
%Zitate??
ROS ist kein eigentliches Betriebssystem im herkömmlichem Sinne, sondern eine Art strukturierte Kommunikationsschicht.
Die Ziele von ROS können zusammengefasst werden zu:
\begin{itemize}
\item Peer-to-peer (System mit vielen laufenden Prozessen auf verschiedenen Hosts)
\item Tool-based (microkernel Design bestehend aus vielen Komponenten, ähnlich zu Linux)
\item multi-lingual (unterstützt viele Computersprachen, z. B. Python, C++, etc.)
\item thin (Wiederverwendbarkeit von Code steht im Mittelpunkt)
\item open source and free (unter der BSD Lizenz)
\end{itemize}
Es ist das einzig existierende Framework, welches sich auf diese Kriterien spezialisiert.
Den Entwicklern von ROS ging es vor allem um die Vereinfachung, Software für eine hohe Zahl an verschiedenen Roboter zu schreiben.
%Zitat
ROS stellt dazu Bibliotheken und Werkzeuge, Hardware Abstraktion, Gerätetreiber, Bibliotheken, Visualisierungen, Nachrichtenvermittlung, Packetverwaltung und andere Komponenten zur Verfügung.

Im Nachfolgenden werden die wichtigsten ROS Core Komponenten kurz beschrieben.

{\bf Topic} Topics können als "named bus" gesehen werden, über welche Nodes Messages verteilen können. Es ähnelt dem Multicasting Prinzip. An Topics kann subscribed (zugehört) oder published (geredet) werden.

{\bf Node} Eine Node ist ein simples Programm, welches jede Funktionalität ermöglicht.  Sie kommunizieren direkt über oben genannte Topics.

{\bf Roscore} Der Roscore kann als Rückgrat des ROS Systems beschrieben werden. Es verwaltet die Registrierung der Nodes und Funktionen in einer Art lookup service für andere Nodes. Es bietet zusätzlich einen Parameter Server, in welchem im Laufenden Betrieb Variablen und Paramater gespeichert werden können und mit welchen gearbeitet werden kann.

{\bf Message} Eine Message kann als Sprache angesehen werden, in welcher Nodes kommunizieren. Es ist eine Struktur aus simplen Parametern.
Beispiel:
\begin{verbatim}
	# This represents a vector in free space. 
	float64 x
	float64 y
	float64 z
\end{verbatim}
Eigene Messages mit den uns bekannten Standardtypen wie int, bool, etc können leicht definiert werden.

{\bf Package} Software in ROS wird mithilfe von Packages verwaltet.
Sie enthalten Nodes, datasets, configuration files, etc.

{\bf Manifest} Sie enthält Meta Informationen über ein ROS Package, wie beispielsweise Abhängigkeiten oder Lizenzinformationen.

{\bf Launchfile} Ein Launchfile ist eine simple XML Datei, welche Informationen über die zu Beginn zu startenden Nodes mit entsprechenden Parametern enthält.
Dies bietet eine komfortablere Alternative, als jedes Node einzeln zu starten.
%Beispiel??
 
{\bf catkin} Catkin ist das seit Groovy in ROS verwendete Workspace-Verwaltungssystem.
Es ist in 4 Spaces unterteilt:
\begin{itemize}
\item Source Space
\item Build Space
\item Devel Space
\item Install Space
\end{itemize}
Catkin bietet uns eine komfortable Möglichkeit über cmake, ROS Packages zu compilieren, Tests an Ihnen durchzuführen und sie schließlich zu installieren.

\section{Problem}

Viele der heutigen Roboter mit ROS-Systemen besitzen einen leistungsstarken und klobigen PC an Ihrer Seite.
Doch für viele Roboteranwendungen würde auch ein kleinerer, leistungschwächerer PC ausreichen.
Dadurch ergeben sich neue Vorteile.

\begin{itemize}
\item weniger Gewicht
\item weniger Kosten
\item Energieverbrauch sinkt $\rightarrow$ Akku hält länger
\item Die Größe des Roboters nimmt ab
\end{itemize}

In unserem Fall wird der Roboter Volksbot mit einem für diesen Zweck überdimensionierten Laptop gesteuert. Wir wollen dieses Problem beheben und uns die obigen Vorteile verschaffen, indem wir ROS auf einem Raspberry Pi laufen lassen.

\subsection{Verwandte Arbeiten}

Master-Thesis:
\begin{enumerate}

\item Robot Navigation in Unknown Environment Based on Combined 2D and 3D Information, Marc Götz, August 2013
\item Semi-Autonomous Grasping of Unknown Objects, Steffen Pfiffner, November 2013
\end{enumerate}

\section{Anforderungen}

\begin{itemize}
\item Datenpakete über das ROS-Netzwerk verschicken
\item Beliebige Datentypen verarbeiten
\item Beliebige Linux-Systeme einbinden
\item Überprüfung von Log-Dateien, Kontrollausgaben etc..
\item Robuste und zuverlässige Kommunikation
\item Modulares und flexibles Netzwerk
\item Repositories sollen leicht in Projekte eingebunden werden
\end{itemize}

{\bf optional}

\begin{itemize}
\item Roboter soll bei Steuerung in richtige Richtungen fahren
\item Roboter soll sofort auf Richtungsanweisungen reagieren
\item Sensibilität der Steuerung sollte einstellbar sein
\item Steuerung über WLAN
\item Raspberry Pi auf Roboter ohne Kabelzgewirr %haben wir mit WLAN nicht
\item ROS-Core des Raspberry beim Hochfahren automatisch starte
\item Leichte Bedienbarkeit des Roboters

\vspace{0,6cm}

\item Streaming-Bild ruckelfrei verarbeiten
\item unkonvertiert Echtzeitübertragung
\item Ausgabe am externem Bildschirm
\end{itemize}


\section{Lösungsvorschläge}


Es wird ein ROS-Master aufgesetzt. Dieser gilt als Knotenpunkt (vergleichbar mit einem Defaultgateway) und sorgt für die Kommunikationsmöglichkeit im ROS-Netzwerk.

Die Verarbeitung von verschiedenen Datentypen ist durch msg und srv realisierbar
%TODO msg/srv näher erklären

Kontrollausgaben und ähnliches werden durch Horchen an Topics mithilfe von echo und durch Ausgabenbereiche im Quellcode durch das Netzwerk realisiert.
 
%Horchen an Topics mit echo + Ausgabe im Code mithilfe ROS-Stream Fkt.

Die Netzwerkstabilität und -zuverläsigkeit könnte durch Begrenzung der zeitgleichen Datenübertragung umgesetzt werden. Zusätzlich kann man eine Überprüfung der verschickten und erwarteten Datentypen einbinden.

%Verschickte und erwartete Datentypen müssen stimmen
%Richtige Konfiguration des Masters und Clients

Ein Modulares und flexibles Netzwerk, sowie das einfache Einbinden von Repositories ist durch ROS in Kombination mit Catkin gegeben. Die Unterstützung beliebiger Linuxsysteme erfolgt ebenfalls durch ROS. Diese Features müssen allerding zuvor eingebunden werden.
%TODO umschreiben!

%durch ROS und catkin gegeben 
%durch catkin gegeben

{\bf optional:}

Die Reaktionszeit 
und Steuerung %hinzugefügt, weil oberer abschnitt auskommentiert
wird durch zuverlässige und leistungstarke Hardware, sowie durch einen effizient geschriebenen Code bestimmt. In diesem Fall können wir die Hardware (mit ausßnahme des Pi) aufrüsten. Der Code lässt sich gar nicht oder nur mühsam verändern und austauschen.
%abhängig vom richtigen Code der Motorsteuerung

%abhängig von Raspberry Pi Hardware und effizientem Code und
%guter Hardware

Um bequem mit dem Raspberry arbeiten zu können, ohne jedes mal den ROS-Core starten zu müssen, muss dieser in den Bootvorgang des Raspbian eingebunden werden.

%sollte in Linux beim booten konfiguriert werden

%gegeben durch gute Smartphone App

vspace{0,6cm}

Ein sauberes und störungsfreies Übertragungsbild hängt hauptsächlich von der Hardware des Raspberry Pi, aber auch von der Codierung ab. Der Stream soll durch  Umleiten des Bildes über das Netzwerk an einen PC-Monitor realisiert werden. Falls dabei Probleme auftreten sollten, können wir versuchen die Codierung zu bearbeiten oder leistungsverstärkende Hardware an den Pi anschließen.

%abhängig von Raspberry Pi Hardware und Übertragungs-Codierung

%abhängig vom Codex Hardware Komponenten

%nötige Hardware und Netzwerk legen

\section{Bewertung der Lösungen}

Bis jetzt sind unsere Lösungsansätze realativ erfolgreich gewesen. Es könnten jedoch Probleme bei der Steuerung des Roboters über das WLAN-Netzwerk entstehen. Der Grund dafür ist die zusätzliche Datenmenge, die verarbeitet werden muss. 

\section{Implementation}

\subsection{Raspbian}

Zuerst wird das Betriebssystem Raspbian auf dem Pi aufgesetzt.
Hierzu gibt es 2 mögliche Vorgehensweisen:
\begin{enumerate}
\item Installation mit NOOBS
\item Flashen der SD-Karte (Linux mittels dd)
\end{enumerate}

Wir haben uns für die 2. Methode entschieden, da NOOBS 6 verschiedene Images anbietet, doch wird in diesem Fall nur Raspbian benötigt.
Zudem erfordert die 2. Vorgehensweise mehr Arbeit mit dem Linux Betriebssystem, was in dieser Vorlesung nur vorteilhaft sein kann.
Die genauen Installationsschritte entnehmen Sie bitte der Quelle (raspbian...) unter dem Unterpunkt Using the Linux command line. \\
Um mögliche Fehlerquellen schon beim Herunterladen der Image Datei zu vermeiden, wird empfohlen, wie in der Anleitung beschrieben die sha1sum zu vergleichen.
%\begin{enumerate}
%\item Mit df -h herausfinden, welchen Namen die SD-Karte trägt (z. B. sdb)
%\item mit dd bs=4M if=~/2012-12-16-wheezy-raspbian.img of=/dev/sdd Image %auf SD-Karte schreiben
%\end{enumerate}

Nun muss nur noch die SD-Karte in den Raspberry eingesteckt werden. Falls eine grüne Leuchte am Raspberry blinkt oder eine Bildschirmausgabe an einem Monitor erscheint, ist dieser Schritt gelungen.

\subsection{ROS aufsetzen}

Es gibt momentan 2 sinnvolle Wege, ROS auf dem Raspbian System aufzusetzen.
%Vorteile, Nachteile
\begin{enumerate}
\item Source packages des ROS-Kerns kompilieren
\item binary packages für die ARM-Architektur installieren
\end{enumerate}

Da die Installation und das Kompilieren von Source zwar sehr lehrreich, doch auch relativ zeitaufwendig ist, benutzen wir die vorhandenen binary packages für ARM. 
Hierzu einfach nach dieser Anleitung vorgehen (Quelle..) \\
Leider werden dadurch nur die grundlegendsten Packages von ROS unterstützt.
Da ein großer Vorteil von ROS die Modularität ist, können leicht benötigte packages über catkin nachinstalliert werden.
Dazu weiter unten die Vorgehensweise erklärt am Beispiel des packages zur Steuerung des Roboters.

\subsection{Netzwerk aufsetzen}
%welche, näher erläutern, sourcen
ROS integriert sich sehr gut in die Shell des Linux Systems ein.
Unterstützt werden mehrere Shell-Typen. In diesem Projekt wird die Bourne Again Shell verwendet.
Damit man auf die ROS typischen Shell Befehle Zugriff hat, muss zuerst gesourced werden.

 \begin{lstlisting}
 source /opt/ros/groovy/setup.bash
 \end{lstlisting}

Mithilfe des source Befehls werden die für ROS relevanten Pfade gespeichert.
%hier vllt. Bild des Inhaltes von ROS
%Shell Bilder, Bsp. von Kommandos

%ab hier weiter!!!!

Für uns ist der Befehl roscore wichtig.
Wir setzen in unserer exports Datei die ROS!MASTER!URI IP-Adresse auf die des Raspberry Pi und dazu den Standardport 11311.
Dies macht den Raspberry zum Master Knotenpunkt, nun können andere Linux-Systeme mit ROS über diesen kommunizieren.
Sie müssen zusätzlich in der exports die ROS!MASTER!URI IP-Adresse des Raspberry angeben.

\subsection{Testen des Netzwerks}

Über das ROS Netzwerk können nun Datenpakete gesendet werden.
Hierzu schicken wir mithilfe der App eine Message, welche die X und Y Koordinaten enthält.

Wir geben in der App die IP des Masters (Pi) an. Das Handy fungiert nun als ROS Node und versendet (publish) diese Messages über einen Topic, an welchem der Pi horcht (subscribe).

Raspberry Pi kann nun mithilfe des ROS Befehls

	rostopic echo ''Topicbezeichnung''
	
aus diesem Topic alle Daten auslesen und ausgeben.
%Bilder der Testdaten
Da die Koordinaten mit denen auf dem Handy übereinstimmen, ist der Netzwerktest erfoglreich.

\subsection{Steuerung des Volksbot}

Für die Ansteuerung des Motorcontrollers des Volksbot benutzen wir ein in einer Projekt-Arbeit entstandenes ROS Package.
Nach einiger Konfiguration konnten wir dieses Package mithilfe catkin!make kompilieren und in unser Projekt integrieren.
Über eine roslaunch Datei wurden die nötigen Nodes und Topics des Packages gestartet.

Die Netzwerk-Funktionalität ist nach den obigen Tests gegeben.
Die Rohdaten des Smartphone-Sensors werden durch das ROS Steuerungspaket entsprechend verändert und über den Raspberry an den Volksbot gesendet.
Der Raspberry wird mithilfe eines USB zu VGA Adapters an den Volksbot angeschlossen. Dieser wird per USB an den Raspberry Pi und per VGA an das Steuerungsmodul des Roboters angeschlossen.


%TODO Konfiguration Motorsteuerung-Paket und Compilieren


%Kontrollausgaben:
%\begin{itemize}

%\item Horchen am ROS-Topic

%\subitem rostopic echo ''Topicbezeichnung''

%\item  

%\end{itemize}

%TODO Netzwerkkomponenten zusammen arbeiten lassen (Hard/-Software)


%TODO Wlan -> Teilproblem


%TODO Kamera -> Teilproblem Zeit


\section{Fazit}
\subsection{Zusammenfassung}

Das Projekt ist durch die hohen Anforderungen und den knappen Zeitraum sehr Zeitintensiv. Allerdings war es auch sehr interessant. Wir haben viel über Linux und ROS gelernt und uns mit Hardware- und Netzwerkkonfiguration außeinander gesetz1 Seitet.

%hohe Anforderungen für knappen Zeitraum
%interessantes, anspruchsvolles Projekt           
%viel über Linux und Ros gelernt
%Hardware- und Netzwerkkonfiguration interessant

\subsection{Ausblick}

In Zukunft kann der Raspberry Pi durch die Tatsache, dass wir ROS benutzt haben, vielseitig im Robotiklabor verwendet werden. Zum Beispiel bei Projekten, die wenig Spielraum bei Größe und Energieverbrauch zulassen.
Durch die Tatsache, dass ROS immer mehr an Beliebtheit gewinnt, nimmt auch die Anzahl an binary-packages und Ausarbeitungen zu. Dies eröffnet wiederum mehr Einsatzmöglichkeiten.
Zum Beispiel kann man nicht nur Roboter, sondern durch das GPIO-Interface auch viele andere Hardwarekomponenten(wie die Bedienoberfläche einer Kaffeemaschine, Lichtschalter, etc.) steuern.  

%Benutzung des Pi's als Hardware Nodes Lab
%Benutzung des Pi's für kleine Roboterprojekte Lab
%Immer mehr binary packages für ROS Pi verfügbar -> mehr Möglichkeiten
%z.B.: GPIO Interface -> Knöpfe Kaffemaschine, Relays, alle möglichen Signale
%auf Hardwareebene

\subsection{Eigene Leistung}

Durch unser Projekt wird der Laptop am ''Volksbot'' durch einen viel kleineren und leichteren Raspberry Pi ersetzt. Außerdem eröffnet sich uns die Möglichkeit, den Pi als Hardware-Node zu benutzen.

\section{Quellen}
\begin{verbatim}

http://de.wikipedia.org/wiki/Raspberry_Pi
http://www.amazon.de/Raspberry-Pi-RBCA000-Mainboard-1176JZF-S/dp/B008PT4GGC
http://www.raspbian.org/
http://www.softwareok.de/?seite=faq-System-Allgemein&faq=13
http://de.wikipedia.org/wiki/ARM-Architektur
http://www.rn-wissen.de/index.php/Raspberry_PI:_GPIO

\end{verbatim}



 
 \begin{lstlisting}[caption={ein paar Zeilen code}\label{lst:test123},captionpos=t]
 
 for i:=maxint to 0 do 
    begin 
    j:=square(root(i)); 
 end; 
 
 int main(void)  {
 printf{"yo");
 }
 \end{lstlisting}

\end{document}
